import esprima
from functools import reduce
import logging

FUNCTION_TYPES = [
  "FunctionExpression",
  "ArrowFunctionExpression",
  "FunctionDeclaration",
]


def getFunctionBlocks(tree):
  # TODO: handle nested functions!
  blocks = []

  if isinstance(tree, esprima.nodes.Node) and tree.type in FUNCTION_TYPES:
    blocks.append(tree)
  elif isinstance(tree, esprima.nodes.Node):
    for (_key, val) in tree.items():
      blocks.extend(getFunctionBlocks(val))
  elif type(tree) is list:
    for subnode in tree:
      blocks.extend(getFunctionBlocks(subnode))

  return blocks


def preprocess(filestring):
  # If the first line is e.g. #!/usr/bin/env node,
  # get rid of it -- it causes esprima to fail
  lines = filestring.split("\n")
  if lines[0].startswith("#!"):
    filestring = "".join(lines[1:])
  return filestring


def getFunctions(filestring):
  filestring = preprocess(filestring)

  tree = None
  try:
    tree = esprima.parseModule(filestring, loc=True, jsx=True, tolerant=True)
  except:
    tree = esprima.parseScript(filestring, loc=True, jsx=True, tolerant=True)

  functions = getFunctionBlocks(tree)

  blocks_linenos = []
  for f in functions:
    start_lineno = f.loc.start.line
    end_lineno = f.loc.end.line
    blocks_linenos.append((start_lineno, end_lineno))

  strings = [""] * len(blocks_linenos)

  for i, line in enumerate(filestring.split("\n")):  
    for j, linenos in enumerate(blocks_linenos):
      if i+1 >= linenos[0] and i+1 <= linenos[1]:
        strings[j] += line + "\n"
  
  strings = [s.strip() for s in strings] # remove the last "\n"
  return (blocks_linenos, strings)


def clean_string(s):
  QUOTES = ["'", '"', '`']
  if s[0] in QUOTES and s[-1] in QUOTES:
    return s[1:-2].strip()

def getTokens(filestring):
  filestring = preprocess(filestring)
  tokens = esprima.tokenize(filestring)
  strings = [clean_string(t.value) for t in tokens if t.type == 'String' and len(t.value) > 2]
  hexes = [t.value for t in tokens if t.type == 'Numeric' and t.value.startswith("0x")]
  identifiers = [t.value for t in tokens if t.type == 'Identifier']

  return strings, hexes, identifiers
  