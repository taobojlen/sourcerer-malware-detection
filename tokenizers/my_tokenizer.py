import sys
import psycopg2
import re
import json
import tarfile
import logging
import hashlib
from collections import Counter
from contextlib import closing

from tqdm.contrib.concurrent import process_map
from tqdm import tqdm
# from mem_top import mem_top

from tokenizers.extract_javascript_function import getFunctions
from classes.file import File
from classes.block import Block
from classes.token import Token
from db import insert_project

FILE_EXTENSIONS = [".js", ".jsx"]
COMMENT_RE_PATTERN = r"\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*|<!--[\s\S]*?-->$"
SEPARATORS = "; . \n [ ] ( ) ~ ! - + & * / % < > ^ | ? { } = # , \" \ : $ ' ` @".split(" ")

logger = logging.getLogger(__name__)

def attempt_decode(raw_data):
  try:
    data = raw_data.decode('utf-8')
  except:
    data = raw_data.decode('utf-8-sig')

  return data


def tokenize_blocks(block_line_nos, blocks: [str]) -> File:
  tokenized_blocks = []
  for ([start_line, end_line], block) in zip(block_line_nos, blocks):
  # Remove tagged comments
    block = re.sub(COMMENT_RE_PATTERN, "", block)

    block_hasher = hashlib.md5()
    block_hasher.update(block.encode('utf-8'))
    block_hash = block_hasher.hexdigest()

    # Tokenize the block
    for sep in SEPARATORS:
      block = block.replace(sep, " ")
    counted_tokens = Counter([b for b in block.split(" ") if b != ""])
    tokens = [Token(k, v) for k, v in counted_tokens.items()]

    tokenized_block = Block(start_line, end_line, block_hash, tokens)
    tokenized_blocks.append(tokenized_block)

  return tokenized_blocks


def process_tarball(tarball, path, conn, malicious, malicious_files):
  processed_files = []
  name = None
  version = None
  for member in tarball.getmembers():
    if not member.isfile() or member.name.startswith("package/node_modules/") or member.name.startswith("node_modules/"):
      continue

    if member.name == 'package/package.json' or member.name == "package.json":
      with tarball.extractfile(member) as f:
        raw_json = f.read()
        try:
          parsed_json = json.loads(attempt_decode(raw_json))
          name = parsed_json["name"]
          version = parsed_json["version"]
        except Exception as e:
          logger.error("Failed to get name of {}".format(path))
          break
    
    else:
      with tarball.extractfile(member) as f:
        file_bytes = f.read()

      if member.name.startswith("package/"):
        file_path = member.name.replace("package/", "", 1) 
      else:
        file_path = member.name
      file_hasher = hashlib.md5()
      file_hasher.update(file_bytes)
      file_hash = file_hasher.hexdigest()
      tokenized_blocks = []

      file_is_malicious = file_path in malicious_files

      if any(member.name.lower().endswith(ext) for ext in FILE_EXTENSIONS):
        file_contents = None
        try:
          file_contents = attempt_decode(file_bytes)
        except:
          logger.warning("Could not extract {} from {}".format(member.name, path))
        if file_contents != None:
          block_line_nos = []
          blocks = []
          try:
            block_line_nos, blocks = getFunctions(file_contents)
          except:
            logger.warning("Could not get functions from {} in {}".format(file_path, path))
          tokenized_blocks = tokenize_blocks(block_line_nos, blocks)

      processed_files.append(File(file_path, file_hash, file_is_malicious, tokenized_blocks))

  if name != None:
    insert_project(name, version, processed_files, malicious, conn)
  else:
    logging.error("Could not find a name for {}".format(path))


def process_project(project_path, malicious=False):
  conn = psycopg2.connect(dbname="sourcerer", user="sourcerer", password="sourcerer")
  if malicious:
    project_path, malicious_files = project_path
  else:
    malicious_files = []
  try:
    # Open tarball with transparent compression
    # (supports gzip, bz2 and lzma)
    with closing(tarfile.open(project_path, "r:*")) as tarball:
      process_tarball(tarball, project_path, conn, malicious, malicious_files)
  except tarfile.ReadError:
    conn.rollback()
    logger.error("Failed to open {}".format(project_path))
    return project_path
  finally:
    conn.close()


def process_malicious_project(project_path):
  process_project(project_path, malicious=True)
