import sys
import re
import json
import tarfile
import logging
from contextlib import closing
from pathlib import Path

from tqdm.contrib.concurrent import process_map
from tqdm import tqdm
# from mem_top import mem_top

from tokenizers.extract_javascript import getStringsAndHexes
from classes.file import File
from classes.block import Block
from classes.token import Token
from util import attempt_decode

ESPRIMA_FILE_EXTENSIONS = [".js", ".jsx"]
FILE_EXTENSIONS = ESPRIMA_FILE_EXTENSIONS + [".ts", ".tsx"]

COMMENT_RE_PATTERN = r"\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*|<!--[\s\S]*?-->$"
SUSPICIOUS_FUNCTIONS = [
  "eval",
  # child_process
  "exec",
  "execSync",
  "spawn",
  # process
  "process.getuid",
  # vm
  "runInThisContext",
  "runInNewContext",
  "runInContext"
]
SUSPICIOUS_STRINGS = [
  ".ssh/",
  ".gpg/",
  ".gpg2",
  ".bashrc",
  ".bash_profile",
  "rm -rf /",
  "/bin/sh",
  "/bin/bash",
  "/etc/passwd",
  "/etc/shadow",
  "shutdown",
  "reboot"
]
SUSPICIOUS_FUNCTION_REGEX = "|".join([re.escape(s) for s in SUSPICIOUS_FUNCTIONS])
SUSPICIOUS_STRING_REGEX = "|".join([re.escape(s) for s in SUSPICIOUS_STRINGS])


logger = logging.getLogger(__name__)


def detect_strings(code_strings):
  # Takes a list of strings extracted from a file
  matches = []
  # Look for naive suspiciuous strings
  for c in code_strings:
    if re.search(SUSPICIOUS_STRING_REGEX, c):
      matches.append(c)

  # Look for attempted obfuscation
  return matches


def process_tarball(tarball, path):
  name = None
  version = None

  suspicious_strings = []
  suspicious_hexes = []
  suspicious_functions = []

  for member in tarball.getmembers():
    if not member.isfile() or member.name.startswith("package/node_modules/") or member.name.startswith("node_modules/"):
      continue

    # Don't process files >5MB
    if member.size > 5000000:
      continue

    if member.name == 'package/package.json' or member.name == "package.json":
      with tarball.extractfile(member) as f:
        raw_json = f.read()
        try:
          parsed_json = json.loads(attempt_decode(raw_json))
          name = parsed_json["name"]
          version = parsed_json["version"]
        except:
          logger.error("Failed to get name of {}".format(path))
          break
    
    else:
      with tarball.extractfile(member) as f:
        file_bytes = f.read()

      if member.name.startswith("package/"):
        file_path = member.name.replace("package/", "", 1) 
      else:
        file_path = member.name

      if any(member.name.lower().endswith(ext) for ext in FILE_EXTENSIONS):
        file_contents = None
        try:
          file_contents = attempt_decode(file_bytes)
        except:
          logger.warning("Could not extract {} from {}".format(member.name, path))
        if file_contents != None:
          # Remove comments
          file_contents = re.sub(COMMENT_RE_PATTERN, "", file_contents)
          # If we can parse this file type, extract strings and hex-encoded numbers
          if any(member.name.lower().endswith(ext) for ext in ESPRIMA_FILE_EXTENSIONS):
            try:
              strings, hexes = getStringsAndHexes(file_contents)
              curr_suspicious_strings = detect_strings(strings)
              if len(curr_suspicious_strings) > 0:
                suspicious_strings.append((curr_suspicious_strings, file_path))
              if len(hexes) > 0:
                suspicious_hexes.append((hexes, file_path))
            except:
              pass

          # Also process the code without lexical analysis
          curr_suspicious_functions = re.findall(SUSPICIOUS_FUNCTION_REGEX, file_contents)
          if len(curr_suspicious_functions) > 0:
            suspicious_functions.append((curr_suspicious_functions, file_path))

  if name == None:
    logger.error("Failed to get name of {}".format(path))
    return

  if suspicious_functions or suspicious_strings or suspicious_hexes:
    output_path = Path("logs/strings/{}.log".format(name.replace("/", "--")))
    with open(output_path, "w") as f:
      for (fs, file_path) in suspicious_functions:
        for func in fs:
          f.write("Function {} in {}\n".format(func, file_path))

      for (strings, file_path) in suspicious_strings:
        for s in strings:
          f.write("String {} in {}\n".format(s, file_path))

      for (hexes, file_path) in suspicious_hexes:
        f.write("{} hex-encoded ints in {}\n".format(len(hexes), file_path))


def process_project_strings(project_path):
  try:
    # Open tarball with transparent compression
    # (supports gzip, bz2 and lzma)
    with closing(tarfile.open(project_path, "r:*")) as tarball:
      process_tarball(tarball, project_path)
  except tarfile.ReadError:
    logger.error("Failed to open {}".format(project_path))
    return project_path
