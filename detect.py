import argparse
import sys
from itertools import chain
from collections import defaultdict
from multiprocessing import Pool
from pathlib import Path, PurePath
import logging

import psycopg2
from tqdm import tqdm

import db
from suspicious_strings import process_project_strings


EMPTY_FILE_MD5 = "d41d8cd98f00b204e9800998ecf8427e"


def invert_dict(dictionary):
  output = defaultdict(list)
  for project_id, hashes_and_paths in dictionary.items():
    for h, p in hashes_and_paths:
      output[h].append((project_id, p))
  return dict(output)


def detect_file_hash_matches(conn):
  malicious_hashes = db.get_malicious_file_hashes(conn)
  # dict of hash -> list of (project ID, path) tuples
  hash_to_loc = invert_dict({i: db.get_project_file_hashes_and_paths(conn, i) for i in malicious_project_ids})
  
  matches = db.get_projects_with_file_hash(conn, malicious_hashes)
  if len(matches) == 0:
    print("No matches found.")
  for name, path, file_hash in matches:
    mal_ids_paths = hash_to_loc[file_hash]
    for malicious_id, malicious_path in mal_ids_paths:
      malicious_name, _malicious_version = db.get_project_details(conn, malicious_id)
      print("{}: {} matches malicious {}: {}".format(name, path, malicious_name, malicious_path))


def detect_block_hash_matches(conn):
  malicious_hashes = db.get_malicious_block_hashes(conn)
  # dict of block hash -> list of (project ID, path) tuples
  hash_to_loc = invert_dict({i: db.get_project_block_hashes_and_file(conn, i) for i in malicious_project_ids})

  matches = db.get_projects_with_block_hash(conn, malicious_hashes)
  if len(matches) == 0:
    print("No matches found.")
  for name, path, block_hash, start_line, end_line in matches:
    mal_ids_paths = hash_to_loc[block_hash]
    for malicious_id, malicious_path in mal_ids_paths:
      malicious_name, _malicious_version = db.get_project_details(conn, malicious_id)
      print("{}: {} ({}-{}) matches block in malicious {}: {}".format(name, path, start_line, end_line, malicious_name, malicious_path))


def detect_suspicious_strings(project_paths):
  log_dir = Path("logs/strings")
  log_dir.mkdir(parents=True, exist_ok=True)
  log_path = log_dir / PurePath("_detect_strings.log")
  logging.basicConfig(
    level=logging.DEBUG,
    filename=log_path,
    format="%(asctime)s %(levelname)-8s %(message)s",
    datefmt="%Y-%m-%dT%H:%M:%S"
  )

  with Pool(processes=12) as p:
    with tqdm(total=len(project_paths)) as pbar:
      for _e in p.imap_unordered(process_project_strings, project_paths):
        pbar.update()
  # for p in tqdm(project_paths):
  #   process_project_strings(p)


if __name__ == "__main__":
  parser = argparse.ArgumentParser()
  parser.add_argument('method', choices=['filehash', 'blockhash', 'token', 'strings'], help="detection method to use")
  parser.add_argument('--projects', help="list of project paths to import")
  args = parser.parse_args()

  if args.method == "strings" and args.projects == None:
    print("Missing --projects flag; exiting.")
    sys.exit(1)

  conn = psycopg2.connect(dbname="sourcerer", user="sourcerer", password="sourcerer")
  malicious_project_ids = db.get_project_ids(conn, malicious=True)
  suspect_project_ids = db.get_project_ids(conn, malicious=False)
  print("Comparing {} projects to {} known malicious ones".format(len(suspect_project_ids), len(malicious_project_ids)))

  if args.method == 'filehash':
    detect_file_hash_matches(conn)
  elif args.method == 'blockhash':
    detect_block_hash_matches(conn)
  elif args.method == 'strings':
    with open(args.projects, "r") as f:
      # list of project paths
      project_paths = [p.strip() for p in f.readlines()]
    detect_suspicious_strings(project_paths)
  elif args.method == 'token':
    pass

