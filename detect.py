import argparse
import sys
from itertools import chain
from multiprocessing import Pool
from pathlib import Path, PurePath
import logging
from math import ceil

from tqdm import tqdm

import db
from suspicious_strings import process_project_strings
from util import istarmap, invert_dict, get_conn
from classes.block_tokens import BlockWithTokens


EMPTY_FILE_MD5 = "d41d8cd98f00b204e9800998ecf8427e"
OVERLAP_THRESHOLD = 0.8


def check_block_overlap(project_id, malicious_blocks):
  conn = get_conn()
  project_blocks = db.get_project_blocks_with_tokens(conn, project_id)
  matches = []
  for proj_block in project_blocks:
    for mal_block in malicious_blocks:
      proj_tokens = set(proj_block.tokens)
      mal_tokens = set(mal_block.tokens)
      match_threshold = ceil(max(len(proj_tokens), len(mal_tokens)) * OVERLAP_THRESHOLD)
      intersection= proj_tokens.intersection(mal_tokens)
      if len(intersection) > match_threshold:
        matches.append((proj_block, mal_block, len(intersection)/len(proj_block.tokens)))
  for pb, mb, overlap in matches:
    print("Match in {} and {}! {}:{}:{} and {}:{}:{} ({}%)".format(pb.project_name, mb.project_name, pb.file_path, pb.start_line, pb.end_line, mb.file_path, mb.start_line, mb.end_line, overlap))


def detect_file_hash_matches(conn):
  malicious_hashes = db.get_malicious_file_hashes(conn)
  # dict of hash -> list of (project ID, path) tuples
  hash_to_loc = invert_dict({i: db.get_project_file_hashes_and_paths(conn, i) for i in malicious_project_ids})
  
  matches = db.get_projects_with_file_hash(conn, malicious_hashes)
  if len(matches) == 0:
    print("No matches found.")
  for name, path, file_hash in matches:
    mal_ids_paths = hash_to_loc[file_hash]
    for malicious_id, malicious_path in mal_ids_paths:
      malicious_name, _malicious_version = db.get_project_details(conn, malicious_id)
      print("{}: {} matches malicious {}: {}".format(name, path, malicious_name, malicious_path))


def detect_block_hash_matches(conn):
  malicious_hashes = db.get_malicious_block_hashes(conn)
  # dict of block hash -> list of (project ID, path) tuples
  hash_to_loc = invert_dict({i: db.get_project_block_hashes_and_file(conn, i) for i in malicious_project_ids})

  matches = db.get_projects_with_block_hash(conn, malicious_hashes)
  if len(matches) == 0:
    print("No matches found.")
  for name, path, block_hash, start_line, end_line in matches:
    mal_ids_paths = hash_to_loc[block_hash]
    for malicious_id, malicious_path in mal_ids_paths:
      malicious_name, _malicious_version = db.get_project_details(conn, malicious_id)
      print("{}: {} ({}-{}) matches block in malicious {}: {}".format(name, path, start_line, end_line, malicious_name, malicious_path))


def detect_suspicious_strings(project_paths):
  log_dir = Path("logs/strings")
  log_dir.mkdir(parents=True, exist_ok=True)
  log_path = log_dir / PurePath("_detect_strings.log")
  logging.basicConfig(
    level=logging.DEBUG,
    filename=log_path,
    format="%(asctime)s %(levelname)-8s %(message)s",
    datefmt="%Y-%m-%dT%H:%M:%S"
  )

  with Pool(processes=12) as p:
    with tqdm(total=len(project_paths)) as pbar:
      for _e in p.imap_unordered(process_project_strings, project_paths):
        pbar.update()


def detect_token_overlap(conn, suspect_project_ids, malicous_project_ids):
  # Get malicious blocks
  malicious_blocks = list(chain(db.get_project_blocks_with_tokens(conn, m_id) for m_id in tqdm(malicious_project_ids)))
  with Pool(processes=12) as p:
    args = [(i, malicious_blocks) for i in suspect_project_ids]
    for _ in tqdm(p.istarmap(check_block_overlap, args), total=len(suspect_project_ids)):
      pass


if __name__ == "__main__":
  parser = argparse.ArgumentParser()
  parser.add_argument('method', choices=['filehash', 'blockhash', 'token', 'strings'], help="detection method to use")
  parser.add_argument('--projects', help="list of project paths to import")
  args = parser.parse_args()

  if args.method == "strings" and args.projects == None:
    print("Missing --projects flag; exiting.")
    sys.exit(1)

  conn = get_conn()
  malicious_project_ids = db.get_project_ids(conn, malicious=True)
  suspect_project_ids = db.get_project_ids(conn, malicious=False)
  print("Comparing {} projects to {} known malicious ones".format(len(suspect_project_ids), len(malicious_project_ids)))

  if args.method == 'filehash':
    detect_file_hash_matches(conn)
  elif args.method == 'blockhash':
    detect_block_hash_matches(conn)
  elif args.method == 'strings':
    with open(args.projects, "r") as f:
      # list of project paths
      project_paths = [p.strip() for p in f.readlines()]
    detect_suspicious_strings(project_paths)
  elif args.method == 'token':
    detect_token_overlap(conn, suspect_project_ids, malicious_project_ids)

