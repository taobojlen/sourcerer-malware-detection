import argparse
import sys
from itertools import chain
from multiprocessing import Pool
from pathlib import Path, PurePath
import logging
from math import ceil

from tqdm import tqdm

import db
import file_db
from suspicious_strings import process_project_strings
from util import invert_dict, get_conn
from classes.block_tokens import BlockWithTokens


EMPTY_FILE_MD5 = "d41d8cd98f00b204e9800998ecf8427e"
OVERLAP_THRESHOLD = 0.8


def check_block_overlap(args):
  project_path, malicious_projects = args
  # project_blocks = db.get_project_blocks_with_tokens(conn, project_id)
  project_name, project_files = file_db.read_project(project_path)
  for filename, proj_blocks in project_files:
    for proj_block in proj_blocks:
      block_tokens = set(proj_block)
      for mal_name, mal_blocks in malicious_projects:
        for mal_block in mal_blocks:
          mal_tokens = set(mal_block)
          intersection = block_tokens.intersection(mal_tokens)
          overlap_denominator = max(len(mal_tokens), len(block_tokens))
          overlap = len(intersection) / overlap_denominator
          if overlap >= OVERLAP_THRESHOLD:
            print("{} in {} matches malicious {} ({}%)".format(filename, project_name, mal_name, overlap * 100))
            print(intersection)


def detect_file_hash_matches(conn):
  malicious_hashes = db.get_malicious_file_hashes(conn)
  # dict of hash -> list of (project ID, path) tuples
  hash_to_loc = invert_dict({i: db.get_project_file_hashes_and_paths(conn, i) for i in malicious_project_ids})
  
  matches = [(name, path, file_hash) for (name, path, file_hash) in db.get_projects_with_file_hash(conn, malicious_hashes) if file_hash != EMPTY_FILE_MD5]
  if len(matches) == 0:
    print("No matches found.")
  for name, path, file_hash in matches:
    try:
      mal_ids_paths = hash_to_loc[file_hash]
    except KeyError:
      print("Could not find paths for {}".format(file_hash))
      continue
    for malicious_id, _malicious_path in mal_ids_paths:
      malicious_name, _malicious_version = db.get_project_details(conn, malicious_id)
      print("{}: {} matches malicious {} ({})".format(name, path, malicious_name, file_hash))


def detect_block_hash_matches(conn):
  malicious_hashes = db.get_malicious_block_hashes(conn)
  # dict of block hash -> list of (project ID, path) tuples
  hash_to_loc = invert_dict({i: db.get_project_block_hashes_and_file(conn, i) for i in malicious_project_ids})

  matches = [m for m in db.get_projects_with_block_hash(conn, malicious_hashes) if m[2] != EMPTY_FILE_MD5]
  if len(matches) == 0:
    print("No matches found.")
  for name, path, block_hash, start_line, end_line in matches:
    try:
      mal_ids_paths = hash_to_loc[block_hash]
    except KeyError:
      print("Could not find paths for {}".format(block_hash))
      continue
    for malicious_id, malicious_path in mal_ids_paths:
      malicious_name, _malicious_version = db.get_project_details(conn, malicious_id)
      print("{}: {} ({}-{}) matches block in malicious {}: {}".format(name, path, start_line, end_line, malicious_name, malicious_path))


def detect_suspicious_strings(project_paths):
  log_dir = Path("logs/strings")
  log_dir.mkdir(parents=True, exist_ok=True)
  log_path = log_dir / PurePath("_detect_strings.log")
  logging.basicConfig(
    level=logging.DEBUG,
    filename=log_path,
    format="%(asctime)s %(levelname)-8s %(message)s",
    datefmt="%Y-%m-%dT%H:%M:%S"
  )

  with Pool(processes=12) as p:
    with tqdm(total=len(project_paths)) as pbar:
      for _e in p.imap_unordered(process_project_strings, project_paths):
        pbar.update()


def detect_token_overlap():
  # Get malicious blocks
  malicious_paths = Path("processed/malicious").glob("*")
  malicious_blocks = []
  for mp in malicious_paths:
    project_name, files = file_db.read_project(mp)
    project_blocks = []
    for filename, blocks in files:
      project_blocks.extend(blocks)
    if project_blocks:
      malicious_blocks.append((project_name, project_blocks))

  suspect_paths = list(Path("processed/suspect").glob("*"))
  # for p in tqdm(suspect_paths):
  #   check_block_overlap(p, malicious_blocks)
  with Pool(processes=12) as p:
    args = [(p, malicious_blocks) for p in suspect_paths]
    with tqdm(total=len(args)) as pbar:
      for _e in p.imap_unordered(check_block_overlap, args):
        pbar.update()


if __name__ == "__main__":
  parser = argparse.ArgumentParser()
  parser.add_argument('method', choices=['filehash', 'blockhash', 'token', 'strings'], help="detection method to use")
  parser.add_argument('--projects', help="list of project paths to import")
  args = parser.parse_args()

  if args.method == "strings" and args.projects == None:
    print("Missing --projects flag; exiting.")
    sys.exit(1)

  conn = get_conn()
  malicious_project_ids = db.get_project_ids(conn, malicious=True)
  suspect_project_ids = db.get_project_ids(conn, malicious=False)
  print("Comparing {} projects to {} known malicious ones".format(len(suspect_project_ids), len(malicious_project_ids)))

  if args.method == 'filehash':
    detect_file_hash_matches(conn)
  elif args.method == 'blockhash':
    detect_block_hash_matches(conn)
  elif args.method == 'strings':
    with open(args.projects, "r") as f:
      # list of project paths
      project_paths = [p.strip() for p in f.readlines()]
    detect_suspicious_strings(project_paths)
  elif args.method == 'token':
    detect_token_overlap()

