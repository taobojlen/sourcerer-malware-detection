import re
import hashlib
import multiprocessing.pool as mpp
from collections import defaultdict

import psycopg2


def attempt_decode(raw_data):
  """
  Decodes utf-8 or utf-8-sig encoded bytes.
  """
  try:
    data = raw_data.decode('utf-8')
  except:
    data = raw_data.decode('utf-8-sig')

  return data


def get_hash(code):
  """
  Given a string of source code (with comments removed),
  normalizes (by removing whitespace) and returns the MD5
  hash.
  """
  cleaned_code = re.sub(r"\s+", "", code)
  hasher = hashlib.md5()
  hasher.update(cleaned_code.encode('utf-8'))
  return hasher.hexdigest()


def invert_dict(dictionary):
  output = defaultdict(list)
  for project_id, hashes_and_paths in dictionary.items():
    for h, p in hashes_and_paths:
      output[h].append((project_id, p))
  return dict(output)


def get_conn():
  return psycopg2.connect(dbname="sourcerer", user="sourcerer", password="sourcerer")


def istarmap(self, func, iterable, chunksize=1):
    """
    starmap-version of imap
    copied from https://stackoverflow.com/a/57364423/3697202
    """
    if self._state != mpp.RUN:
        raise ValueError("Pool not running")

    if chunksize < 1:
        raise ValueError(
            "Chunksize must be 1+, not {0:n}".format(
                chunksize))

    task_batches = mpp.Pool._get_tasks(func, iterable, chunksize)
    result = mpp.IMapIterator(self._cache)
    self._taskqueue.put(
        (
            self._guarded_task_generation(result._job,
                                          mpp.starmapstar,
                                          task_batches),
            result._set_length
        ))
    return (item for chunk in result for item in chunk)


mpp.Pool.istarmap = istarmap
